Explorando el SVM-KNN con problemas de visión  Joon Hyuck Choi (jchoilOO, jchoi100@jhu.edu) Joo Chang Lee (jlee381, jlee381@jhu.edu)  20 de noviembre de 2016  1 Resumen  El algoritmo k-Nearest Neighbor (KNN) es un método no paramétrico utilizado para clasificar y regresión. En una asignación de tarea anterior, implementamos el clasificador estándar de KNN Y una de sus variantes, la distancia ponderada KNN. Sentimos la necesidad de dar otro paso desde Esta asignación y explorar otro tipo de algoritmo KNN, que es un poco más involucrado.  La variante KNN que exploramos en este trabajo es el algoritmo SVM-KNN, a&#39;KNN que hace Uso de un subproceso SVM de multiclase del núcleo como un subprocedimiento. El enfoque de vecinos más cercanos en Problemas de reconocimiento ha demostrado que funcionan bien en el pasado [1]. Sin embargo, a pesar de sus bene- Porque el enfoque NN puede sufrir de alta variación debido al muestreo finito. La incorporación . De una SVM puede remediar esta situación. V  Obsérvese que los dos casos extremos del SVM-KNN Son el KNN estándar para valores de K pequeños Y la SVM regular para K - n. El algoritmo primero intenta clasificar multiclass utilizando el Estándar KNN con un sistema de votación unánime. Cuando al menos una votación es diferente, se El kernel mutliclass SVM &#39;para la predicción. unesdoc.unesco.org unesdoc.unesco.org  El uso de un SVM puede ser eficaz en el vecindario de un pequeño número de ejemplos y un pequeño Número de clases [1] Nuestro objetivo es probar este algoritmo en dos conjuntos de datos: MNIST [3] y USPS [4] Los objetivos extendidos incluyen la prueba del algoritmo en el conjunto de datos Caltech 101 [5], que Consiste en imágenes más sofisticadas del mundo real con más etiquetas  2 Métodos  Primero ejecutar nuestro propio estándar KNN con voto unánime. &#39;En caso de desacuerdo, utilice el kernel SVM de scikitlearn con nuestra propia métrica de distancia como entrada. Implementar por nuestra cuenta el núcleo Truco proporcionado en [l] según sea necesario:  1 K (rc.y) = 5 (d (x, 0) + d (y, 0) ), - d (x, y))